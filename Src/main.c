/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdio.h>
#include "i2c.h"
#include "uart.h"

void set_bmp280(void);
void get_temp(int);
long temp_calc(long);
void write_data(int,int);
void get_data(int);
void store_data(void);
void show_temp(void);
void print_temp_values(void);
void systick_init(void);
void delay1(void);

uint8_t data_temp[20];
uint8_t data_buffer[10];
int addrs = 0;
int temp_value[100];
char temp_buff[10];

int main(void)
{
	config_clk();
	config_gpio();
	config_i2c();

	uart2_config();

	set_bmp280();

   for(int i=0;i<10;i++){
	get_temp(3);
	store_data();
   }

	addrs = 0;

   for(int i=0;i<10;i++){
	get_data(2);
    show_temp();
   }

   for(int i=0;i<3;i++){
	   sprintf(temp_buff,"%d",temp_value[i]);
	   print_temp_values();
   }
}


void set_bmp280(){
	i2c_start();
	i2c_address(0xEC); //Address of BMP280


	i2c_write(0xF4);//Mode and sampling regsiter
	i2c_write(0x23);//Normal Mode ,16x sampling
	i2c_write(0xF5);//config register
	i2c_write(0x80);//standby_mode-500 and filter and NO SPI
}

void get_temp(int byteno){
    int i=0;
    i2c_start();
    i2c_address(0xEC);
    i2c_write(0xFA);//setting pointer to MSB of temperature register

    i2c_start();
    i2c_address(0xED);//address + Read
    uint32_t temp = I2C_SR1 | I2C_SR2; //clearing SR1 and SR2

    for(i=0;i<byteno-1;i++){
       I2C_CR1 |= (1<<10);//Acknowledge
       while(!(I2C_SR1 & (1<<6))); //wait till data register is empty
       data_temp[i] = I2C_DR; //read the data from DR
    }

    I2C_CR1 &= ~(1<<10);//no ACK
    while(!(I2C_SR1 & (1<<6)));//wait till data register is empty
    data_temp[i] = I2C_DR;

    i2c_stop();
}

long temp_calc(long adc_T){
	long int t_fine;
	long signed int var1, var2, T;
	unsigned short dig_T1 = 27504;
	short dig_T2 = 26435;
	short dig_T3 = -1000;
	var1 = ((((adc_T >> 3) - ((long int)dig_T1 << 1))) * ((long int)dig_T2)) >> 11;
	var2 = (((((adc_T >> 4) - ((long int)dig_T1)) * ((adc_T >> 4) - ((long int)dig_T1))) >> 12) * ((long int)dig_T3)) >> 14;
	t_fine = var1 + var2;
	T = (t_fine * 5 + 128) >> 8;
	return T;
}

void write_data(int addr,int data){
	i2c_start();
	i2c_address(0xA0);

	delay1();

	//starting address
	 i2c_write((int) (addr>>8));
	 i2c_write((int) (addr & 0xFF));

	//data
	char c;

	i2c_write((uint8_t)(data>>8));
	delay1();

	i2c_write((uint8_t)(data & 0xFF));
	delay1();

	i2c_stop();

	delay1();
}

void get_data(int byteno){
    int i=0;
    i2c_start();
    i2c_address(0xA0);

    i2c_write((int) (addrs>>8));
    i2c_write((int) (addrs & 0xFF));

    i2c_start();
    i2c_address(0xA1);//address + Read
    uint8_t temp = I2C_SR1 | I2C_SR2; //clearing SR1 and SR2

    for(i=0;i<byteno-1;i++){
       I2C_CR1 |= (1<<10);//Acknowledge
       while(!(I2C_SR1 & (1<<6))); //wait till data register is empty
       data_buffer[i] = I2C_DR; //read the data from DR
    }

    I2C_CR1 &= ~(1<<10);//no ACK
    while(!(I2C_SR1 & (1<<6)));//wait till data register is empty
    data_buffer[i] = I2C_DR;

    i2c_stop();

    addrs = addrs+2;
}


void store_data(){
	long raw_temp;
	int temperature;

	raw_temp = (((long)data_temp[0]<<12) | ((long)data_temp[1]<<4)|((long)data_temp[2]>>4))& 0xFFFFFFFF ;
	temperature = temp_calc(raw_temp);
	write_data(addrs,temperature);
	addrs = addrs + 2;
}

void show_temp(){
	temp_value[(addrs-2)/2] = ((int)(data_buffer[0]<<8)) | ((int)(data_buffer[1]));
}

void print_temp_values(){
	for(int i=0;i<4;i++){
		if(i==2){
			send_char('.');
		}
		send_char(temp_buff[i]);
	}
	send_char('C');
	send_char('\n');
}

void delay1(){
	volatile long i;
	for(i=0;i<10000;i++);
}

